--Database devellopment part-2

SELECT 'Hello WOrld' AS Text;
SELECT 'He hasn''t seen this thing';
SELECT 'He\'s good at sports;
SELECT $message$ He's good at sports $message$ UNION
SELECT $$ This is single quote ' and this is backslash\ $$;

do 
'declare
   film_count integer;
begin 
   select count(*) into film_count
   from film;
   raise notice ''The number of films: %'', film_count;
end;';


--block structure
DO
$$
<<new_block>>
DECLARE
	cnt integer :=0;
BEGIN
	--comments can be added like this
	SELECT count(*) into cnt FROM film;
	--to sidplay msg
	RAISE NOTICE 'This is single quote '' and the count is %',cnt;
END new_block $$;

create function find(
   id int
) returns int
language sql
as 
  'select film_id from film 
   where film_id = id';

SELECT find(100);
drop function find;


DO
$$
--optional label block
DECLARE
	x int :=1;
	y char(4) ='temp';
	z timestamp =now();
	price numeric(10,2) = 12.4;
BEGIN 
	RAISE NOTICE 'The x is %, y is % and price is %.
	The timestamp is %',x,y,price,z	;
END $$;


SELECT * FROM address;
--sapmle block
DO
$$
<<TEMP>>
DECLARE
	id int;
	name varchar;
	time TIMESTAMP := now();
BEGIN
	SELECT city_id,district INTO id,name FROM address
	WHERE address_id=100;
	--displayb msg
	RAISE NOTICE 'City is : % and district :%
	Current time is :% ', id,name,time;
END
$$;

SELECT * FROM address;
SELECT pg_sleep(0.5);
SELECT * FROM address WHERE address_id=2;

DO $$
DECLARE
	new_time1 time = now();
	
	new_time2 time = now();
	
BEGIN
	RAISE NOTICE 'The time is : %',new_time1;
	PERFORM pg_sleep(5);
	RAISE NOTICE 'Now the time is : %',new_time2;
END $$;


--copy datatype
SELECT * FROM film;

DO $$
DECLARE
	name varchar;
	temp film.rating%type;
BEGIN
	SELECT title, rating into name,temp FROM film;
	RAISE NOTICE 'NAME: % and RATING: %',name,temp;
END
$$;

--subblock variables

DO
$$
<<block1>>
DECLARE
	temp int :=10;
BEGIN
	RAISE NOTICE 'Value before sencond declaration : %',temp;
	DECLARE
		temp int :=20;
	BEGIN
		RAISE NOTICE 'Value after second declaration : %',temp;
		RAISE NOTICE 'Vakue from outer block using block.var : % ',block1.temp;
	END;
	RAISE NOTICE 'Value : %',temp;
END;
$$

--row type variable
SELECT * FROM actor;
DO
$$
<<temp>>
DECLARE
	actor_row actor%rowtype;
BEGIN
	SELECT * into actor_row FROM actor where actor_id=10;
	RAISE NOTICE 'id: % and name: % ',actor_row.actor_id,actor_row.first_name;
END;
$$

--record type variable
SELECT * FROM film;
DO
$$
DECLARE
	rec RECORD;
BEGIN
	SELECT film_id,title into rec from film where film_id=2;
	
	RAISE NOTICE 'name of the film is % where the id is %',rec.film_id,rec.title;
END;
$$
--constant
DO
$$
DECLARE
	pi CONSTANT int :=3.14;
	area float :=pi*2*2;
BEGIN
	RAISE NOTICE 'Area of a circle with radius 2 is = %',area;
END;
$$

-- Control structure  
-- if statement 
SELECT * FROM city;
SELECT * from country;

DO
$$
DECLARE
	rec record;
	country varchar;
BEGIN
	SELECT * INTO rec FROM CITY where city_id=10;
	IF rec.country_id =44 THEN
		country ='INDIA';
	ELSIF rec.country_id = 50 THEN
		country = 'JAPAN';
	ELSE
		country='NONE';
	END IF;
	RAISE NOTICE 'Country with city id 10 is %',country;
END
$$

-- case statement 
--simple
DO
$$
DECLARE
	country int;
	name varchar;
BEGIN
	SELECT country_id into country FROM city WHERE city_id=10;
	
	CASE country
		WHEN 1 THEN
			name='Afghanistan';
		WHEN 44 THEN
			name='INDIA';
		WHEN 50 THEN
			name='JAPAN';
		ELSE
			name = 'NONE';
	END CASE;
	RAISE NOTICE 'Country name with city is 10 is %',name;
END;
$$

-- loop statement 
DO
$$
DECLARE 
	cnt int:=1;
BEGIN
	<<temp1>>
	LOOP
		RAISE NOTICE 'counte is %',cnt;
		cnt = cnt+1;
		IF cnt>5 THEN
			EXIT;
		END IF;
	END LOOP temp1;
END;
$$

-- for loop 

-- while loop 
DO 
$$
DECLARE
	cnt int :=1;
BEGIN
	WHILE cnt<=10 LOOP
		RAISE NOTICE 'count : %',cnt;
		cnt = cnt+1;
	END LOOP;
END;
$$

DO 
$$
DECLARE
	cnt int :=1;
BEGIN
	WHILE cnt<=10 LOOP
		RAISE NOTICE 'count : %',cnt;
		cnt = cnt+1;
		IF cnt =2 THEN
			CONTINUE;
		END IF;
	END LOOP;
END;
$$

--User define function
CREATE FUNCTION my_fun(id int)
	RETURNS varchar
	LANGUAGE plpgsql
AS $$
DECLARE
	name varchar;
BEGIN
	SELECT first_name into name FROM actor where actor_id = id; 
	return name;
END;
$$
SELECT my_fun(10);
DROP FUNCTION my_fun;

create or replace function get_film(
    out min_len int,
    out max_len int,
    out avg_len numeric) 
language plpgsql
as $$
begin
  
  select min(length),
         max(length),
		 avg(length)::numeric(5,1)
  into min_len, max_len, avg_len
  from film;

end;
$$
SELECT get_film();

--PROCEDURE
drop table if exists accounts;

create table accounts (
    id int generated by default as identity,
    name varchar(100) not null,
    balance dec(15,2) not null,
    primary key(id)
);

insert into accounts(name,balance)
values('Bob',10000);

insert into accounts(name,balance)
values('Alice',10000);

select * from accounts;

create or replace procedure transfer(
   sender int,
   receiver int, 
   amount dec
)
language plpgsql    
as $$
begin
    -- subtracting the amount from the sender's account 
    update accounts 
    set balance = balance - amount 
    where id = sender;

    -- adding the amount to the receiver's account
    update accounts 
    set balance = balance + amount 
    where id = receiver;

    commit;
end;
$$

CALL transfer(1,2,100);
SELECT * FROM accounts;
DROP PROCEDURE transfer;

--new procedure
SELECT * FROM employee;

CREATE OR REPLACE PROCEDURE my_procedure(incr numeric(10,2))
LANGUAGE plpgsql
AS $$
BEGIN
	UPDATE employee
	SET salary = salary + (salary*(incr/100));
-- 	COMMIT;
END;
$$

SELECT * FROM employee;
CALL my_procedure(10);
SELECT * FROM employee;

DROP PROCEDURE IF EXISTS my_procedure;

SELECT * FROM PAYMENT;

CREATE OR REPLACE PROCEDURE new_procedure(id INT,amt numeric(5,2))
LANGUAGE plpgsql
AS
$$
DECLARE
	temp_id INT :=id;
BEGIN
	UPDATE payment
		SET amount = amount + amt
		WHERE payment_id=temp_id;
END;
$$

SELECT * FROM payment ORDER BY payment_id;
CALL new_procedure(17503,10.0);
SELECT * FROM payment ORDER BY payment_id;


--EXCEPTION Handling
DO
$$
DECLARE
	rec record;
	id int:=1000000;
BEGIN
	RAISE NOTICE 'LOG 1';
	
	SELECT * into STRICT rec FROM film WHERE film_id=id;
	RAISE NOTICE 'LOG 3';
	RAISE NOTICE '%',rec.title;
	EXCEPTION
		WHEN no_data_found THEN
			RAISE EXCEPTION 'OOPS There is no record found with this lang id';
		WHEN too_many_rows THEN
			RAISE NOTICE 'LOG 2';
			RAISE EXCEPTION 'There area multiple rows';
	
END;
$$ 


--cursor
--declare-open-fetch-?empty-close

--simple cursor
SELECT * FROM employee;

CREATE OR REPLACE PROCEDURE simple_proc()
LANGUAGE plpgsql
AS
$$
DECLARE
	cnt int:=1;
	string varchar(100);
	--declaring the cursor for a query
	c1 CURSOR FOR SELECT emp_name,dept_name FROM employee ORDER BY emp_name;-- dept_name;
	rec record;
BEGIN
	OPEN c1;
	LOOP
		FETCH c1 INTO rec;
		EXIT WHEN NOT FOUND;
		string = 'name: '||rec.emp_name||'and title: '||rec.dept_name;
		RAISE NOTICE '%: %',cnt,string;
		cnt = cnt +1;
	END LOOP;
	CLOSE c1;
	EXCEPTION
		WHEN OTHERS THEN
			RAISE NOTICE 'Something went wrong';
END;
$$

CALL simple_proc();

--paramiterized cursor

CREATE OR REPLACE PROCEDURE param(id int)
LANGUAGE plpgsql
AS
$$
DECLARE
	string varchar(100);
	rec RECORD;
	irec RECORD;
	curs1 CURSOR(cur_film_id int) FOR
		SELECT title from film where film_id=cur_film_id;
BEGIN
	FOR irec in SELECT film_id FROM film_actor WHERE actor_id = id
	LOOP
		OPEN curs1(irec.film_id);
		LOOP
			FETCH curs1 into rec;
			EXIT WHEN NOT FOUND;
-- 			string := 'title : '||rec.title;
			RAISE NOTICE '%',rec.title;
			
		END LOOP;
		CLOSE curs1;
	END LOOP;
-- 	EXCEPTION
-- 		WHEN OTHERS THEN
-- 			RAISE NOTICE 'Something went wrong';
END;
$$
SELECT * FROM film;
CALL param(1);
DROP PROCEDURE IF EXISTS param;

DO
$$
DECLARE 
	i record;
BEGIN
	for i in SELECT title FROM film WHERE film_id in (SELECT film_id FROM film_actor where actor_id=1)
	LOOP
	raise notice '%',i;
	END LOOP;
END;
$$

--Trigger functions
SELECT * FROM post1;
CREATE OR REPLACE FUNCTION tmp()
RETURNS TRIGGER
LANGUAGE plpgsql
AS
$$
BEGIN
	RAISE NOTICE 'ALA BHAiiiiii Inserted';
	RETURN post1.id;
END;
$$

CREATE TRIGGER temp_trig
AFTER INSERT
ON post2
FOR EACH ROW
EXECUTE PROCEDURE tmp();

SELECT * FROM post2;
INSERT INTO post1(id,fname,lname,num,insert_time) VALUES (123,'one19','two19',234,CURRENT_TIMESTAMP);

--Created a function that use trigger's arg
CREATE OR REPLACE PROCEDURE temp2()
RETURNS TRIGGER
LANGUAGE PlPgSQL
AS
$$
DECLARE
	name varchar;
	string VARCHAR;
BEGIN
	RAISE NOTICE 'title is';
	RAISE NOTICE '%',TG_ARGV[0];
END;
$$

SELECT * FROM post1;
CREATE OR REPLACE TRIGGER trigu
AFTER INSERT
ON post2
FOR EACH ROW
EXECUTE FUNCTION temp2('Something');

INSERT INTO post2 VALUES(11,'abc@xyz.com','2001-01-01');

SELECT * FROM post2;
SELECT * FROM film;
SELECT * FROM payment;
--aggregate function
SELECT AVG(amount) from payment;
SELECT MIN(length) AS min_val, MAX(length) AS max_val from film where language_id=1;
SELECT customer_id,sum(amount) from payment GROUP BY customer_id;

SELECT * FROM city;

--math function
SELECT customer_id,CEIL(amount) FROM payment;
SELECT CBRT(27);
SELECT DEGREES(1);
SELECT city_id,LOG(city_id) AS log_val from city;
SELECT EXP(1);
SELECT TRUNC(RANDOM()*100);
SELECT MOD(123,5);

--date function
SELECT AGE(CURRENT_TIMESTAMP,CURRENT_TIMESTAMP);
SELECT AGE(now(),'01-12-2001');
SELECT EXTRACT(day FROM now());
SELECT EXTRACT (second from CURRENT_TIMESTAMP);

--string function
SELECT ASCII('A');
SELECT CHR(90);
SELECT CONCAT('Helllo','Morning');
SELECT CONCAT_WS(' ','Helllo','Morning');
SELECT LEFT('UGflaiuwhfl',5)
SELECT UPPER(title) from film where film_id=1;
select * from post1;
SELECT LOWER(fname) FROM post1;
SELECT TRIM('       one         ');
SELECT LPAD('ab dc',8,'0');
SELECT MD5('temp') = MD5('temp');

SELECT LTRIM('00123');
SELECT title, POSITION('a' in title)
FROM film limit 5;
select SPLIT_PART('01-02-03-012-a','-',4) from post1;
SELECT REPEAT('*',8);
SELECT REPLACE(title,'a','x') FROM film limit 10;
SELECT REVERSE(title) FROM film limit 10;

--window function
SELECT emp_id,dept_name,salary, AVG(salary) OVER (PARTITION BY dept_name) FROM employee;
SELECT emp_id,dept_name, AVG(salary) FROM employee GROUP ;
SELECT emp_id,dept_name,salary, rank() OVER (PARTITION BY dept_name ORDER BY SALARY) FROM employee;

--row number
SELECT *,row_number() over() as num FROM employee;
SELECT *,row_number() over(PARTITION BY dept_name ORDER BY emp_id) as num FROM employee;

--rank 
--dense rank
SELECT *,rank() over(ORDER BY salary) AS rnk FROM employee;
SELECT *,rank() over(PARTITION BY dept_name ORDER BY salary) AS rnk FROM employee;

SELECT *,
rank() over(PARTITION BY dept_name ORDER BY salary) AS rnk,
dense_rank() over(PARTITION BY dept_name ORDER BY salary) AS dense_rnk 
FROM employee;


--lag
--lead
SELECT rating, count(*) FROM (SELECT title,film_id,length,rating,
lag(length) over(PARTITION BY rating)
from film) nw GROUP BY rating;

SELECT *,
LAG(salary,2,0) OVER(PARTITION BY dept_name) 
FROM employee;

SELECT title,film_id,length,
LEAD(length) over()
from film limit 10;

SELECT *,
LAG(salary,2,0) 
	(PARTITION BY dept_name) AS lag,
LEAD(salary) 
	OVER(PARTITION BY dept_name) AS lead
FROM employee;

SELECT *,
LAG(salary) OVER(PARTITION BY dept_name),
CASE 
	WHEN LAG(salary) OVER(PARTITION BY dept_name) > salary
		THEN 'HIGHER'
	WHEN LAG(salary) OVER(PARTITION BY dept_name) < salary
		THEN 'LOWER'
	ELSE 'SAME'
END form
FROM employee;

--first value
--last value
SELECT title,length,rating, 
FIRST_VALUE(length) OVER(
	PARTITION BY rating 
	ORDER BY length) 
	AS firstval,
LAST_VALUE(length) 
	OVER(PARTITION BY rating 
		 ORDER BY length) 
		 AS lastval
FROM film;

SELECT 
	emp_id,
	dept_name,
	salary,
	NTILE(3) OVER(
		PARTITION BY dept_name
		ORDER BY salary
	)
FROM
	employee;
	

select * from tmp;
